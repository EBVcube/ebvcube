% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebv_data_read.R
\name{ebv_data_read}
\alias{ebv_data_read}
\title{Read data from EBV NetCDF}
\usage{
ebv_data_read(
  filepath,
  datacubepath,
  timestep,
  delayed = TRUE,
  sparse = TRUE,
  raster = FALSE,
  ignore.RAM = FALSE
)
}
\arguments{
\item{filepath}{Path to the NetCDF file.}

\item{datacubepath}{Path to the datacube (use ebv_datacubepaths()).}

\item{timestep}{Choose one or several timesteps (vector).}

\item{delayed}{Default. Returns data as DelayedArray object. More timesteps are not returned as a 3D array but as a list of the DelayedArrays (one array per band).}

\item{sparse}{Set to True if the data contains a lot emtpy raster cells. Only relevant for DelayedArray. No further implementation by now.}

\item{raster}{Set to True and 'delayed' to False to get a raster. If both arguments are set to False the function returns an array.}

\item{ignore.RAM}{Checks if there is enough space in your memory to read the data. Can be switched off (set to True).}
}
\value{
Array, Raster or DelayedArray object containing the data of the corresponding datacube and timestep(s).
}
\description{
Read one or more layers from one datacube of the NetCDF file. Decide between in-memory array, in-memory raster or an array-like object (DelayedArray) pointing to the on-disk file. Latter is useful for data that exceeds your memory.
}
\examples{
file <- paste0(path.package("ebvnetcdf"),"/extdata/cSAR_idiv_v1.nc")
datacubes <- ebv_datacubepaths(file)
# cSAR.delayedarray <- ebv_data_read(file, datacubes[1,1], c(1,6))
# cSAR.raster <- ebv_data_read(file, datacubes[1,1], 1, delayed = F, raster = T)
# cSAR.array <- ebv_data_read(file, datacubes[1,1], c(1,1,3), delayed = F, raster = F)
}
